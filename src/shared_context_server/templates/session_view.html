{% extends "base.html" %}

{% block title %}Session: {{ session.purpose[:30] }} - Shared Context Server{% endblock %}

{% block content %}
<div class="session-view">
    <!-- Sticky Navigation Container -->
    <div class="sticky-nav-container">
        <div class="session-info">
            <div class="session-header-row">
                <div class="session-title-row">
                    <div class="status-indicator" data-tooltip="Live Updates">
                        <div id="ws-indicator" class="status-dot connecting"></div>
                    </div>
                    <h1 class="session-title">{{ session.purpose }}</h1>
                </div>
                <div class="session-header-controls">
                    <button class="btn btn-primary auto-scroll-toggle" id="auto-scroll-toggle" onclick="toggleAutoScroll()" data-tooltip="Disable auto-scroll" style="display: none;">
                        <span class="btn-icon">‚è∏Ô∏è</span>
                    </button>
                    <button class="btn btn-secondary" id="markdown-toggle-btn" onclick="toggleMarkdownRendering()" data-tooltip="Toggle Markdown/Raw">
                        <span class="btn-icon">üìù</span>
                    </button>
                    <button class="btn btn-secondary" id="refresh-btn" onclick="window.location.reload()" data-tooltip="Refresh" style="display: none;">
                        <span class="btn-icon">üîÑ</span>
                    </button>
                    <div class="activity-indicator" id="activity-status-indicator" data-activity-timestamp="{{ session.last_activity or session.created_at }}" data-tooltip="Loading activity status...">
                        <div class="activity-dot"></div>
                    </div>
                </div>
            </div>
            <div class="session-meta">
                <div class="meta-item">
                    <span class="meta-label">Session ID:</span>
                    <span class="meta-value">
                        <code>{{ session.id }}</code>
                        <button class="copy-btn" onclick="copyToClipboard('{{ session.id }}')">üìã</button>
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Created by:</span>
                    <span class="meta-value">{{ session.created_by }}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Participants:</span>
                    <span class="meta-value">
                        <span class="stat-icon">üë•</span>
                        {{ session.participant_count or 0 }} {% if (session.participant_count or 0) == 1 %}participant{% else %}participants{% endif %}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Created at:</span>
                    <span class="meta-value timestamp-value">
                        <script>
                            document.write((function() {
                                const timestamp = "{{ session.created_at }}";
                                if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                    const date = new Date(parseFloat(timestamp) * 1000);
                                    if (!isNaN(date.getTime())) {
                                        return date.toLocaleString(undefined, {
                                            year: 'numeric',
                                            month: 'numeric',
                                            day: 'numeric',
                                            hour: 'numeric',
                                            minute: '2-digit',
                                            second: '2-digit',
                                            timeZoneName: 'short'
                                        });
                                    }
                                }
                                return timestamp;
                            })());
                        </script>
                    </span>
                    <div class="timestamp-relative session-created-relative" data-original-timestamp="{{ session.created_at }}">
                        <script>
                            document.write((function() {
                                const timestamp = "{{ session.created_at }}";
                                if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                    const date = new Date(parseFloat(timestamp) * 1000);
                                    if (!isNaN(date.getTime())) {
                                        const now = new Date();
                                        const diffMs = now - date;
                                        const diffMins = Math.floor(diffMs / 60000);
                                        const diffHours = Math.floor(diffMins / 60);
                                        const diffDays = Math.floor(diffHours / 24);

                                        if (diffDays > 0) {
                                            return diffDays + (diffDays === 1 ? ' day ago' : ' days ago');
                                        } else if (diffHours > 0) {
                                            return diffHours + (diffHours === 1 ? ' hour ago' : ' hours ago');
                                        } else if (diffMins > 0) {
                                            return diffMins + (diffMins === 1 ? ' minute ago' : ' minutes ago');
                                        } else {
                                            return 'just now';
                                        }
                                    }
                                }
                                return '';
                            })());
                        </script>
                    </div>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Last Activity:</span>
                    {% if session.last_activity %}
                    <span class="meta-value timestamp-value">
                        <script>
                            document.write((function() {
                                const timestamp = "{{ session.last_activity }}";
                                if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                    const date = new Date(parseFloat(timestamp) * 1000);
                                    if (!isNaN(date.getTime())) {
                                        return date.toLocaleString(undefined, {
                                            year: 'numeric',
                                            month: 'numeric',
                                            day: 'numeric',
                                            hour: 'numeric',
                                            minute: '2-digit',
                                            second: '2-digit',
                                            timeZoneName: 'short'
                                        });
                                    }
                                }
                                return timestamp;
                            })());
                        </script>
                    </span>
                    <div class="timestamp-relative session-activity-relative" data-original-timestamp="{{ session.last_activity }}">
                        <script>
                            document.write((function() {
                                const timestamp = "{{ session.last_activity }}";
                                if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                    const date = new Date(parseFloat(timestamp) * 1000);
                                    if (!isNaN(date.getTime())) {
                                        const now = new Date();
                                        const diffMs = now - date;
                                        const diffMins = Math.floor(diffMs / 60000);
                                        const diffHours = Math.floor(diffMins / 60);
                                        const diffDays = Math.floor(diffHours / 24);

                                        if (diffDays > 0) {
                                            return diffDays + (diffDays === 1 ? ' day ago' : ' days ago');
                                        } else if (diffHours > 0) {
                                            return diffHours + (diffHours === 1 ? ' hour ago' : ' hours ago');
                                        } else if (diffMins > 0) {
                                            return diffMins + (diffMins === 1 ? ' minute ago' : ' minutes ago');
                                        } else {
                                            return 'just now';
                                        }
                                    }
                                }
                                return '';
                            })());
                        </script>
                    </div>
                    {% else %}
                    <span class="meta-value">No activity</span>
                    {% endif %}
                </div>
            </div>
        </div>

        <div class="tab-container">
            <div class="tab-header">
                <button class="tab-button active" onclick="switchTab('messages')" id="messages-tab">
                    Messages ({{ messages|length }})
                </button>
                <button class="tab-button" onclick="switchTab('memory')" id="memory-tab">
                    Memory ({{ session_memory|length }})
                </button>
            </div>
        </div>

        <!-- Message Visibility Filters (only show for messages tab) -->
        <div class="message-filters" id="message-filters">
            <span class="filter-label">Show:</span>
            <button class="filter-btn active" data-visibility="all" onclick="filterMessages('all')">All</button>
            <button class="filter-btn" data-visibility="public" onclick="filterMessages('public')">Public</button>
            <button class="filter-btn" data-visibility="private" onclick="filterMessages('private')">Private</button>
            <button class="filter-btn" data-visibility="agent_only" onclick="filterMessages('agent_only')">Agent Only</button>
            <button class="filter-btn" data-visibility="admin_only" onclick="filterMessages('admin_only')">Admin Only</button>
        </div>
    </div>

    <div class="session-content">

            <div class="tab-content">
                <div class="tab-pane active" id="messages-pane">
                    <div class="messages-list" id="messages-list">
            {% if messages %}
                {% for message in messages %}
                <div class="message-item" data-message-id="{{ message.id }}" data-visibility="{{ message.visibility }}">
                    <div class="message-header">
                        <div class="message-sender">
                            <span class="sender-icon">
                                {% if message.sender_type == 'claude' %}ü§ñ
                                {% elif message.sender_type == 'gemini' %}‚ú®
                                {% else %}üë§{% endif %}
                            </span>
                            <span class="sender-name">{{ message.sender }}</span>
                        </div>
                        <div class="message-meta">
                            <div class="message-timestamp">
                                <div class="timestamp-main">
                                    <script>
                                        document.write((function() {
                                            const timestamp = "{{ message.timestamp }}";
                                            if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                                const date = new Date(parseFloat(timestamp) * 1000);
                                                if (!isNaN(date.getTime())) {
                                                    return date.toLocaleString(undefined, {
                                                        year: 'numeric',
                                                        month: 'numeric',
                                                        day: 'numeric',
                                                        hour: 'numeric',
                                                        minute: '2-digit',
                                                        second: '2-digit',
                                                        timeZoneName: 'short'
                                                    });
                                                }
                                            }
                                            return timestamp;
                                        })());
                                    </script>
                                </div>
                                <div class="timestamp-relative">
                                    <script>
                                        document.write((function() {
                                            const timestamp = "{{ message.timestamp }}";
                                            if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                                const date = new Date(parseFloat(timestamp) * 1000);
                                                if (!isNaN(date.getTime())) {
                                                    const now = new Date();
                                                    const diffMs = now - date;
                                                    const diffMins = Math.floor(diffMs / 60000);
                                                    const diffHours = Math.floor(diffMins / 60);
                                                    const diffDays = Math.floor(diffHours / 24);

                                                    if (diffDays > 0) {
                                                        return diffDays + (diffDays === 1 ? ' day ago' : ' days ago');
                                                    } else if (diffHours > 0) {
                                                        return diffHours + (diffHours === 1 ? ' hour ago' : ' hours ago');
                                                    } else if (diffMins > 0) {
                                                        return diffMins + (diffMins === 1 ? ' minute ago' : ' minutes ago');
                                                    } else {
                                                        return 'just now';
                                                    }
                                                }
                                            }
                                            return '';
                                        })());
                                    </script>
                                </div>
                            </div>
                            <span class="visibility-badge visibility-{{ message.visibility }}">
                                {{ message.visibility }}
                            </span>
                        </div>
                    </div>

                    <div class="message-content">
                        <div class="message-text" data-markdown="{{ message.content|e }}">{{ message.content }}</div>
                        {% if message.metadata and message.metadata != '{}' %}
                        <div class="message-metadata">
                            <details>
                                <summary>Metadata</summary>
                                <pre><code>{{ message.metadata | tojson(indent=2) }}</code></pre>
                            </details>
                        </div>
                        {% endif %}
                    </div>
                </div>
                {% endfor %}
            {% else %}
            <div class="empty-messages">
                <div class="empty-icon">üí¨</div>
                <h3>No Messages Yet</h3>
                <p>Messages will appear here when agents add them to this session.</p>
            </div>
            {% endif %}
                    </div>
                </div>

                <div class="tab-pane" id="memory-pane">
                    {% if session_memory %}
                    <div class="memory-table-container">
                        <table class="memory-table">
                            <thead>
                                <tr>
                                    <th class="th-key">
                                        <span class="th-icon">üîë</span>
                                        <span class="th-text">Key</span>
                                    </th>
                                    <th class="th-agent">
                                        <span class="th-icon">ü§ñ</span>
                                        <span class="th-text">Agent</span>
                                    </th>
                                    <th class="th-preview">
                                        <span class="th-icon">üëÅÔ∏è</span>
                                        <span class="th-text">Preview</span>
                                    </th>
                                    <th class="th-created">
                                        <span class="th-icon">üìÖ</span>
                                        <span class="th-text">Created</span>
                                    </th>
                                    <th class="th-expires">
                                        <span class="th-icon">‚è∞</span>
                                        <span class="th-text">Expires</span>
                                    </th>
                                    <th class="th-actions">
                                        <span class="th-icon">‚öôÔ∏è</span>
                                        <span class="th-text">Actions</span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for entry in session_memory %}
                                <tr class="memory-row">
                                    <td class="memory-key">
                                        <code>{{ entry.key|e }}</code>
                                    </td>
                                    <td class="memory-agent">
                                        <span class="agent-badge">{{ entry.agent_id|e }}</span>
                                    </td>
                                    <td class="memory-value">
                                        {% set value_text = entry.value|e %}
                                        <span class="value-preview">{{ value_text }}</span>
                                        {% if value_text|length > 200 %}
                                            <span class="expand-indicator" title="Click 'View Full' to see complete value">üîç</span>
                                        {% endif %}
                                    </td>
                                    <td class="memory-created">
                                        <span class="timestamp-value">
                                            <script>
                                                document.write((function() {
                                                    const timestamp = "{{ entry.created_at }}";
                                                    if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                                        const date = new Date(parseFloat(timestamp) * 1000);
                                                        if (!isNaN(date.getTime())) {
                                                            return date.toLocaleString(undefined, {
                                                                year: 'numeric',
                                                                month: 'numeric',
                                                                day: 'numeric',
                                                                hour: 'numeric',
                                                                minute: '2-digit',
                                                                second: '2-digit',
                                                                timeZoneName: 'short'
                                                            });
                                                        }
                                                    }
                                                    return timestamp;
                                                })());
                                            </script>
                                        </span>
                                    </td>
                                    <td class="memory-expires">
                                        {% if entry.expires_at %}
                                        <span class="expires-value">
                                            <script>
                                                document.write((function() {
                                                    const timestamp = "{{ entry.expires_at }}";
                                                    if (/^\d+(\.\d+)?$/.test(timestamp)) {
                                                        const date = new Date(parseFloat(timestamp) * 1000);
                                                        if (!isNaN(date.getTime())) {
                                                            const now = new Date();
                                                            const diffMs = date.getTime() - now.getTime();
                                                            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                                                            const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

                                                            if (diffMs <= 0) {
                                                                return '<span class="ttl-expired">Expired</span>';
                                                            } else if (diffHours < 1) {
                                                                return '<span class="ttl-soon">' + diffMins + 'm</span>';
                                                            } else if (diffHours < 24) {
                                                                return '<span class="ttl-hours">' + diffHours + 'h ' + diffMins + 'm</span>';
                                                            } else {
                                                                const diffDays = Math.floor(diffHours / 24);
                                                                return '<span class="ttl-days">' + diffDays + 'd ' + (diffHours % 24) + 'h</span>';
                                                            }
                                                        }
                                                    }
                                                    return timestamp;
                                                })());
                                            </script>
                                        </span>
                                        {% else %}
                                        <span class="ttl-permanent">Permanent</span>
                                        {% endif %}
                                    </td>
                                    <td class="memory-actions">
                                        <button class="btn btn-sm btn-secondary view-full-btn"
                                                data-key="{{ entry.key|e }}"
                                                onclick="viewFullValue('{{ entry.key|e }}')">
                                            <span class="btn-icon">üëÅÔ∏è</span>
                                            <span class="btn-text">View Full</span>
                                        </button>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                    {% else %}
                    <div class="empty-state">
                        <div class="empty-icon">üß†</div>
                        <h3>No Session Memory</h3>
                        <p>Session-scoped memory entries will appear here when agents create them.</p>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Modal for viewing full values -->
<div id="value-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Memory Value</h3>
            <div class="modal-controls">
                <button id="view-toggle" class="btn btn-sm" onclick="toggleView()" title="Toggle between highlighted and raw view">
                    <span id="toggle-text">Raw</span>
                </button>
                <span class="modal-close" onclick="closeModal()">&times;</span>
            </div>
        </div>
        <div class="modal-body">
            <div class="modal-key">
                <strong>Key:</strong> <code id="modal-key"></code>
            </div>
            <div class="modal-value">
                <strong>Value:</strong>
                <pre id="modal-value"></pre>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeModal()">Close</button>
        </div>
    </div>
</div>

<script>
// This page manages its own WebSocket; disable global init
window.SCS_DISABLE_GLOBAL_WS = true;
// Debug control: enable with window.SCS_DEBUG=true, ?debug=1 or localStorage('scs_debug')==='1'
const SCS_DEBUG = (window.SCS_DEBUG === true)
    || (new URLSearchParams(window.location.search).get('debug') === '1')
    || (localStorage.getItem('scs_debug') === '1');
const dlog = (...args) => { if (SCS_DEBUG) console.debug(...args); };
let websocket;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
let pingIntervalId = null;

// Modal view state
let currentViewMode = 'highlighted'; // 'highlighted' or 'raw'
let currentModalKey = null;
let currentRawValue = null;
let currentParsedValue = null;

// Auto-scroll state management
let isAtBottom = true;           // Track user scroll position
let autoScrollEnabled = true;    // Track auto-scroll preference
let unreadCount = 0;            // Count messages when scrolled up
let scrollDetectionTimeout;     // Debounce scroll events

// WebSocket connection management
function connectWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = window.location.hostname;
    const wsPort = '{{ websocket_port }}'; // WebSocket server port from config
    const wsUrl = `${protocol}//${wsHost}:${wsPort}/ws/{{ session_id }}`;

    websocket = new WebSocket(wsUrl);

    websocket.onopen = function(event) {
        updateConnectionStatus('connected');
        reconnectAttempts = 0;

        // Send periodic heartbeat
        if (pingIntervalId) {
            clearInterval(pingIntervalId);
        }
        pingIntervalId = setInterval(() => {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send('ping');
            }
        }, 30000);
    };

    websocket.onmessage = function(event) {
        try {
            if (event.data === 'pong') {
                return; // Heartbeat response
            }

            const message = JSON.parse(event.data);
            handleRealtimeMessage(message);
        } catch (error) {
            console.error('Failed to parse WebSocket message:', error);
        }
    };

    websocket.onclose = function(event) {
        updateConnectionStatus('disconnected');
        if (pingIntervalId) {
            clearInterval(pingIntervalId);
            pingIntervalId = null;
        }

        // Attempt to reconnect
        if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            setTimeout(() => {
                connectWebSocket();
            }, 2000 * reconnectAttempts);
        }
    };

    websocket.onerror = function(error) {
        console.error('WebSocket error:', error);
        updateConnectionStatus('error');
        if (pingIntervalId) {
            clearInterval(pingIntervalId);
            pingIntervalId = null;
        }
    };
}

// Update connection status indicator
function updateConnectionStatus(status) {
    const indicator = document.getElementById('ws-indicator');
    const statusIndicator = indicator.parentElement; // Get the status-indicator container
    const refreshBtn = document.getElementById('refresh-btn');

    indicator.className = 'status-dot';

    switch (status) {
        case 'connected':
            indicator.classList.add('online');
            statusIndicator.setAttribute('data-tooltip', 'Live Updates');
            // Hide refresh button when connected
            if (refreshBtn) refreshBtn.style.display = 'none';
            break;
        case 'disconnected':
            indicator.classList.add('offline');
            statusIndicator.setAttribute('data-tooltip', 'Disconnected');
            // Show refresh button when disconnected
            if (refreshBtn) refreshBtn.style.display = 'flex';
            break;
        case 'error':
            indicator.classList.add('error');
            statusIndicator.setAttribute('data-tooltip', 'Connection Error');
            // Show refresh button on error
            if (refreshBtn) refreshBtn.style.display = 'flex';
            break;
        default:
            indicator.classList.add('connecting');
            statusIndicator.setAttribute('data-tooltip', 'Connecting...');
            // Hide refresh button while connecting
            if (refreshBtn) refreshBtn.style.display = 'none';
    }
}

// Handle real-time message updates
function handleRealtimeMessage(message) {
    if (message.type === 'new_message') {
        addNewMessage(message.data);
    } else if (message.type === 'memory_update') {
        handleMemoryUpdate(message.data);
    } else if (message.type === 'session_update') {
        // Only reload for structural changes, not normal message additions
        // This prevents jarring page reloads during normal conversation
        // Session structural update received - consider manual refresh if needed
    }
}

// Handle real-time memory updates
function handleMemoryUpdate(memoryData) {
    // Update memory tab count
    updateMemoryCount();

    // If memory tab is active, update the table
    const memoryPane = document.getElementById('memory-pane');
    if (memoryPane.classList.contains('active')) {
        addOrUpdateMemoryEntry(memoryData);
    }
}

// Update memory count in tab
function updateMemoryCount() {
    const memoryRows = document.querySelectorAll('#memory-pane .memory-row');
    const memoryTab = document.getElementById('memory-tab');
    memoryTab.textContent = `Memory (${memoryRows.length})`;
}

// Add or update memory entry in the table
function addOrUpdateMemoryEntry(memoryData) {
    const memoryTable = document.querySelector('#memory-pane .memory-table tbody');
    const emptyState = document.querySelector('#memory-pane .empty-state');

    // Remove empty state if present
    if (emptyState) {
        emptyState.remove();
        // Create table if it doesn't exist
        if (!memoryTable) {
            createMemoryTable();
        }
    }

    if (memoryTable) {
        // Check if entry already exists
        const existingRow = document.querySelector(`#memory-pane .memory-row[data-key="${memoryData.key}"]`);

        if (existingRow) {
            // Update existing row
            updateMemoryRow(existingRow, memoryData);
        } else {
            // Add new row
            const newRow = createMemoryRow(memoryData);
            // Insert at the top (most recent first)
            memoryTable.insertBefore(newRow, memoryTable.firstChild);
        }

        updateMemoryCount();
    }
}

// Create memory row element
function createMemoryRow(memoryData) {
    const row = document.createElement('tr');
    row.className = 'memory-row';
    row.setAttribute('data-key', memoryData.key);

    const timestamp = (function() {
        const ts = memoryData.created_at;
        if (typeof ts === 'number') {
            const date = new Date(ts * 1000);
            if (!isNaN(date.getTime())) {
                return date.toLocaleString(undefined, {
                    year: 'numeric',
                    month: 'numeric',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    second: '2-digit',
                    timeZoneName: 'short'
                });
            }
        }
        return ts;
    })();

    const valuePreview = memoryData.value.length > 100 ?
        memoryData.value.substring(0, 100) + '...' :
        memoryData.value;

    row.innerHTML = `
        <td class="memory-key">
            <code>${escapeHtml(memoryData.key)}</code>
        </td>
        <td class="memory-agent">
            <span class="agent-badge">${escapeHtml(memoryData.agent_id)}</span>
        </td>
        <td class="memory-value">
            <span class="value-preview">${escapeHtml(valuePreview)}</span>
        </td>
        <td class="memory-created">
            <span class="timestamp-value">${timestamp}</span>
        </td>
        <td class="memory-actions">
            <button class="btn btn-sm btn-secondary" onclick="viewFullValue('${escapeHtml(memoryData.key)}', ${JSON.stringify(memoryData.value).replace(/'/g, '\\\'')})">
                View Full
            </button>
        </td>
    `;

    return row;
}

// Update existing memory row
function updateMemoryRow(row, memoryData) {
    const valueCell = row.querySelector('.memory-value .value-preview');
    const timestampCell = row.querySelector('.timestamp-value');
    const actionButton = row.querySelector('.memory-actions button');

    const valuePreview = memoryData.value.length > 100 ?
        memoryData.value.substring(0, 100) + '...' :
        memoryData.value;

    if (valueCell) {
        valueCell.textContent = valuePreview;
    }

    if (timestampCell) {
        const timestamp = (function() {
            const ts = memoryData.updated_at || memoryData.created_at;
            if (typeof ts === 'number') {
                const date = new Date(ts * 1000);
                if (!isNaN(date.getTime())) {
                    return date.toLocaleString(undefined, {
                        year: 'numeric',
                        month: 'numeric',
                        day: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit',
                        second: '2-digit',
                        timeZoneName: 'short'
                    });
                }
            }
            return ts;
        })();
        timestampCell.textContent = timestamp;
    }

    if (actionButton) {
        actionButton.setAttribute('onclick', `viewFullValue('${escapeHtml(memoryData.key)}', ${JSON.stringify(memoryData.value).replace(/'/g, '\\\'')})"`);
    }
}

// Add new message to the UI with cross-tab awareness
function addNewMessage(messageData) {
    const messagesList = document.getElementById('messages-list');
    const emptyMessages = messagesList.querySelector('.empty-messages');

    // Remove empty state if present
    if (emptyMessages) {
        emptyMessages.remove();
    }

    // Create new message element
    const messageElement = createMessageElement(messageData);
    messagesList.appendChild(messageElement);

    // Check if we're on messages tab
    const isOnMessagesTab = isMessagesTabActive();

    if (isOnMessagesTab) {
        // Normal auto-scroll handling when on messages tab
        handleSmartAutoScroll(messageElement);
    } else {
        // Handle cross-tab message arrival - ALWAYS show notification when not on messages tab
        // This promotes users that there are new messages regardless of auto-scroll state
        incrementUnreadCount();
        addToggleNotification();

        if (autoScrollEnabled) {
            // Auto-scroll is enabled - when they return to messages tab, they'll auto-scroll to latest
            // New message arrived while on other tab - will auto-scroll when returning to messages tab
        } else {
            // Auto-scroll is disabled - notification will persist until manually cleared
            // New message arrived while on other tab with auto-scroll disabled - added persistent notification
        }
    }

    // Update message count in header
    updateMessageCount();

    // Update activity indicator with current timestamp for new messages
    updateActivityIndicatorForNewMessage();

    // Update session header Last Activity timestamp from message data
    updateSessionActivityTimestampFromMessage(messageData);
}

// Helper function to get relative timestamp ("just now", "5 minutes ago", etc.)
function getRelativeTimestamp(timestamp) {
    let date;

    // Handle both Unix timestamp (numeric) and ISO string formats
    if (/^\d+(\.\d+)?$/.test(timestamp)) {
        date = new Date(parseFloat(timestamp) * 1000);
    } else {
        date = new Date(timestamp);
    }

    if (isNaN(date.getTime())) {
        return '';
    }

    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffDays > 0) {
        return diffDays + (diffDays === 1 ? ' day ago' : ' days ago');
    } else if (diffHours > 0) {
        return diffHours + (diffHours === 1 ? ' hour ago' : ' hours ago');
    } else if (diffMins > 0) {
        return diffMins + (diffMins === 1 ? ' minute ago' : ' minutes ago');
    } else {
        return 'just now';
    }
}

// Create message element
function createMessageElement(message) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message-item';
    messageDiv.setAttribute('data-message-id', message.id);
    messageDiv.setAttribute('data-visibility', message.visibility);

    const senderIcon = getSenderIcon(message.sender_type);
    const timestamp = (function() {
        const ts = message.timestamp;
        let date;

        // Handle both Unix timestamp (numeric) and ISO string formats
        if (/^\d+(\.\d+)?$/.test(ts)) {
            // Unix timestamp format (seconds)
            date = new Date(parseFloat(ts) * 1000);
        } else {
            // ISO string format or other date string
            date = new Date(ts);
        }

        if (!isNaN(date.getTime())) {
            return date.toLocaleString(undefined, {
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            });
        }

        return ts; // Fallback to raw timestamp if parsing fails
    })();

    messageDiv.innerHTML = `
        <div class="message-header">
            <div class="message-sender">
                <span class="sender-icon">${senderIcon}</span>
                <span class="sender-name">${message.sender}</span>
            </div>
            <div class="message-meta">
                <div class="message-timestamp">
                    <div class="timestamp-main">${timestamp}</div>
                    <div class="timestamp-relative">${getRelativeTimestamp(message.timestamp)}</div>
                </div>
                <span class="visibility-badge visibility-${message.visibility}">
                    ${message.visibility}
                </span>
            </div>
        </div>
        <div class="message-content">
            <div class="message-text" data-markdown="${escapeHtml(message.content)}">${escapeHtml(message.content)}</div>
        </div>
    `;

    // Apply markdown rendering to new message if enabled
    if (isMarkdownEnabled && typeof marked !== 'undefined' && typeof DOMPurify !== 'undefined') {
        try {
            const messageTextEl = messageDiv.querySelector('.message-text');
            const markdownContent = message.content;

            marked.setOptions({
                gfm: true,
                breaks: false,
                pedantic: false,
                sanitize: false
            });

            const rawHtmlContent = marked.parse(markdownContent);
            const sanitizedHtmlContent = DOMPurify.sanitize(rawHtmlContent, {
                ALLOWED_TAGS: [
                    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                    'p', 'br', 'div', 'span',
                    'strong', 'b', 'em', 'i', 'u', 'code', 'pre',
                    'ul', 'ol', 'li',
                    'blockquote',
                    'a',
                    'table', 'thead', 'tbody', 'tr', 'th', 'td',
                    'input'
                ],
                ALLOWED_ATTR: [
                    'href', 'title', 'alt', 'class', 'id',
                    'type', 'checked', 'disabled', 'start'
                ],
                ALLOW_DATA_ATTR: false,
                ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|#):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
                FORBID_ATTR: ['onerror', 'onload', 'onclick', 'onmouseover', 'onfocus', 'onblur', 'onchange', 'onsubmit', 'src'],
                FORBID_TAGS: ['script', 'object', 'embed', 'form', 'button', 'img'],
                ADD_ATTR: ['target']
            });

            messageTextEl.innerHTML = sanitizedHtmlContent;

            // Apply syntax highlighting if Prism is available
            if (typeof Prism !== 'undefined') {
                const codeElements = messageTextEl.querySelectorAll('code[class*="language-"]');
                codeElements.forEach(code => {
                    Prism.highlightElement(code);
                });
            }
        } catch (error) {
            console.error('Error rendering markdown for new message:', error);
        }
    }

    return messageDiv;
}

// Get sender icon based on type
function getSenderIcon(senderType) {
    switch (senderType) {
        case 'claude': return 'ü§ñ';
        case 'gemini': return '‚ú®';
        default: return 'üë§';
    }
}

// Smart auto-scroll functionality
function isAtBottomOfContainer(element, threshold = 64) {
    return (element.scrollHeight - element.scrollTop - element.clientHeight) < threshold;
}

function handleSmartAutoScroll(messageElement) {
    const messagesList = document.getElementById('messages-list');
    const wasAtBottom = isAtBottomOfContainer(messagesList);

    isAtBottom = wasAtBottom;

    if (autoScrollEnabled) {
        // Auto-scroll is enabled - always scroll to new message
        messageElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
        hideAutoScrollToggle();
    } else {
        // Auto-scroll is disabled - show toggle button
        showAutoScrollToggle();
        incrementUnreadCount();
        addToggleNotification();
    }
}

function showAutoScrollToggle() {
    const toggleButton = document.getElementById('auto-scroll-toggle');
    if (toggleButton) {
        toggleButton.style.display = 'flex';
        updateAutoScrollToggleUI();
    }
}

function hideAutoScrollToggle() {
    const toggleButton = document.getElementById('auto-scroll-toggle');
    if (toggleButton) {
        toggleButton.style.display = 'none';
        unreadCount = 0;
    }
}

function incrementUnreadCount() {
    unreadCount++;
    updateAutoScrollToggleUI();
}

function updateAutoScrollToggleUI() {
    const toggleButton = document.getElementById('auto-scroll-toggle');
    const toggleIcon = toggleButton?.querySelector('.btn-icon');

    if (!toggleButton || !toggleIcon) return;

    // Check if we're in memory view
    const isInMemoryView = !isMessagesTabActive();

    if (isInMemoryView) {
        // In memory view - always show return arrow and preserve glow effect
        toggleIcon.textContent = '‚Ü©Ô∏è';
        const tooltipText = unreadCount > 0 ? `Return to messages (${unreadCount} new messages)` : 'Return to messages';
        toggleButton.setAttribute('data-tooltip', tooltipText);

        // Keep the current class to preserve any glow effects, but ensure secondary styling
        const hasNotification = toggleButton.classList.contains('new-messages-notification');
        toggleButton.className = 'btn btn-secondary auto-scroll-toggle';
        if (hasNotification) {
            toggleButton.classList.add('new-messages-notification'); // Restore glow effect
        }
    } else {
        // In messages view - normal auto-scroll toggle behavior
        if (autoScrollEnabled) {
            toggleIcon.textContent = '‚è∏Ô∏è';
            toggleButton.setAttribute('data-tooltip', 'Disable auto-scroll');
            toggleButton.className = 'btn btn-primary auto-scroll-toggle';
        } else {
            toggleIcon.textContent = '‚ñ∂Ô∏è';
            const tooltipText = unreadCount > 0 ? `Enable auto-scroll (${unreadCount} new messages)` : 'Enable auto-scroll';
            toggleButton.setAttribute('data-tooltip', tooltipText);
            toggleButton.className = 'btn btn-secondary auto-scroll-toggle';
        }
    }
}

function toggleAutoScroll() {
    // Check if we're currently on the messages tab
    const isOnMessagesTab = isMessagesTabActive();

    if (!isOnMessagesTab) {
        // If not on messages tab, switch to messages tab first
        switchTab('messages');

        // Clear notifications since user is navigating to messages
        clearToggleNotification();
        unreadCount = 0;

        // Auto-enable scroll and scroll to latest message
        autoScrollEnabled = true;

        // Brief delay to ensure tab switch completes, then scroll
        setTimeout(() => {
            const messagesList = document.getElementById('messages-list');
            const messages = messagesList.querySelectorAll('.message-item');

            if (messages.length > 0) {
                const lastMessage = messages[messages.length - 1];
                lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }

            isAtBottom = true;
            hideAutoScrollToggle();
        }, 100);

        return; // Exit early since we handled the cross-tab case
    }

    // Normal toggle behavior when already on messages tab
    autoScrollEnabled = !autoScrollEnabled;

    if (autoScrollEnabled) {
        // Auto-scroll was just enabled - scroll to latest and hide toggle
        const messagesList = document.getElementById('messages-list');
        const messages = messagesList.querySelectorAll('.message-item');

        if (messages.length > 0) {
            const lastMessage = messages[messages.length - 1];
            lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        isAtBottom = true;
        hideAutoScrollToggle();
        clearToggleNotification(); // Clear any notifications
        unreadCount = 0; // Reset unread count
    } else {
        // Auto-scroll was just disabled - show toggle button
        showAutoScrollToggle();
    }
}

function initializeScrollDetection() {
    const messagesList = document.getElementById('messages-list');
    if (!messagesList) return;

    // Immediate scroll event handler (minimal debounce for performance)
    const handleScroll = () => {
        clearTimeout(scrollDetectionTimeout);
        scrollDetectionTimeout = setTimeout(() => {
            const wasAtBottom = isAtBottomOfContainer(messagesList, 20); // More strict threshold
            const scrollDistance = messagesList.scrollHeight - messagesList.scrollTop - messagesList.clientHeight;
            isAtBottom = wasAtBottom;

            // Debug logging to understand scroll behavior
            // Scroll detection logic

            if (wasAtBottom) {
                // User scrolled back to bottom
                if (autoScrollEnabled) {
                    // Auto-scroll is enabled - hide toggle button
                    hideAutoScrollToggle();
                    // At bottom with auto-scroll enabled - hiding toggle
                } else {
                    // Auto-scroll is disabled - keep toggle visible but update UI
                    showAutoScrollToggle();
                    // At bottom but auto-scroll disabled - showing toggle
                }
            } else {
                // User scrolled up (away from bottom)
                if (autoScrollEnabled) {
                    // User manually scrolled away from bottom while auto-scroll was enabled
                    // Automatically disable auto-scroll
                    autoScrollEnabled = false;
                    showAutoScrollToggle();
                    // Auto-scroll automatically disabled - user scrolled up
                } else {
                    // Auto-scroll already disabled - just show the toggle
                    showAutoScrollToggle();
                    // Auto-scroll already disabled - keeping toggle visible
                }
            }
        }, 16); // ~60fps refresh rate (16ms) for responsive feel
    };

    messagesList.addEventListener('scroll', handleScroll);
}

// Update message count in header
function updateMessageCount() {
    const messages = document.querySelectorAll('.message-item');
    const messagesTab = document.getElementById('messages-tab');
    messagesTab.textContent = `Messages (${messages.length})`;
}

// Visual notification functions for cross-tab messaging
function addToggleNotification() {
    const toggleButton = document.getElementById('auto-scroll-toggle');
    if (toggleButton) {
        toggleButton.classList.add('new-messages-notification');
        // Added breathing notification effect to toggle button

        // If auto-scroll is enabled, clear notification when user switches back to messages tab
        if (autoScrollEnabled) {
            // For auto-scroll enabled case, clear notification after tab switch
            const clearOnTabSwitch = () => {
                clearToggleNotification();
            };
            setTimeout(clearOnTabSwitch, 1000); // Brief delay to show the effect
        }
    }
}

function clearToggleNotification() {
    const toggleButton = document.getElementById('auto-scroll-toggle');
    if (toggleButton) {
        toggleButton.classList.remove('new-messages-notification');
    }
}

function isMessagesTabActive() {
    const messagesTab = document.getElementById('messages-tab');
    return messagesTab && messagesTab.classList.contains('active');
}

// Refresh all timestamps in the interface
function refreshAllTimestamps() {
    dlog('üïê Refreshing all timestamps...');

    // Update message timestamps
    refreshMessageTimestamps();

    // Update session info timestamps (created at, last activity)
    refreshSessionTimestamps();

}

// Refresh relative timestamps for all messages
function refreshMessageTimestamps() {
    const messageElements = document.querySelectorAll('.message-item');
    let updatedCount = 0;

    messageElements.forEach(messageEl => {
        const timestampRelative = messageEl.querySelector('.timestamp-relative');
        if (timestampRelative) {
            // Get the original timestamp from data attribute or timestamp element
            const timestampMain = messageEl.querySelector('.timestamp-main');
            if (timestampMain && timestampMain.textContent) {
                const originalTimestamp = timestampMain.textContent.trim();
                // Update relative timestamp
                const newRelativeTime = getRelativeTimestamp(originalTimestamp);
                if (timestampRelative.textContent !== newRelativeTime) {
                    timestampRelative.textContent = newRelativeTime;
                    updatedCount++;
                }
            }
        }
    });

}

// Refresh session info timestamps (created at, activity status)
function refreshSessionTimestamps() {
    let updatedCount = 0;

    // Update session created timestamp
    const createdTimestamp = document.querySelector('.session-created-relative');
    if (createdTimestamp && createdTimestamp.dataset.originalTimestamp) {
        const newRelativeTime = getRelativeTimestamp(createdTimestamp.dataset.originalTimestamp);
        if (createdTimestamp.textContent !== newRelativeTime) {
            createdTimestamp.textContent = newRelativeTime;
            updatedCount++;
        }
    }

    // Update session activity timestamp
    const activityTimestamp = document.querySelector('.session-activity-relative');
    if (activityTimestamp && activityTimestamp.dataset.originalTimestamp) {
        const newRelativeTime = getRelativeTimestamp(activityTimestamp.dataset.originalTimestamp);
        if (activityTimestamp.textContent !== newRelativeTime) {
            activityTimestamp.textContent = newRelativeTime;
            updatedCount++;
        }
    }

    // Update activity status indicator (this handles the visual indicator)
    applyActivityStatusToIndicator();

}

// Tab switching functionality with auto-scroll persistence
function switchTab(tabName) {
    const previousTab = document.querySelector('.tab-button.active')?.id.replace('-tab', '');

    // Store current scroll position if switching away from messages tab
    if (previousTab === 'messages') {
        const messagesList = document.getElementById('messages-list');
        if (messagesList) {
            window.lastMessagesScrollPosition = messagesList.scrollTop;
            window.lastMessagesScrollHeight = messagesList.scrollHeight;
        }
    }

    // Hide all tab panes
    const panes = document.querySelectorAll('.tab-pane');
    panes.forEach(pane => pane.classList.remove('active'));

    // Remove active class from all tab buttons
    const buttons = document.querySelectorAll('.tab-button');
    buttons.forEach(button => button.classList.remove('active'));

    // Show selected tab pane
    document.getElementById(tabName + '-pane').classList.add('active');

    // Add active class to selected tab button
    document.getElementById(tabName + '-tab').classList.add('active');

    // Handle messages tab-specific behavior
    if (tabName === 'messages') {
        dlog(`üîÑ Switching to messages tab. Auto-scroll enabled: ${autoScrollEnabled}`);

        // Clear any notification glow effect
        clearToggleNotification();

        // Handle auto-scroll restoration based on previous state
        setTimeout(() => {
            const messagesList = document.getElementById('messages-list');
            if (!messagesList) {
                dlog('‚ùå Messages list not found!');
                return;
            }

            dlog(`üìä Messages list found. Current scrollTop: ${messagesList.scrollTop}, scrollHeight: ${messagesList.scrollHeight}`);

            if (autoScrollEnabled) {
                // Auto-scroll was enabled - always scroll to latest message
                const messages = messagesList.querySelectorAll('.message-item');
                dlog(`üìù Found ${messages.length} messages`);

                if (messages.length > 0) {
                    const lastMessage = messages[messages.length - 1];
                    dlog('üéØ Attempting smooth scroll to last message...');

                    // Use smooth scroll directly for better UX
                    lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    dlog(`‚úÖ Smooth scrolled to latest. New scrollTop: ${messagesList.scrollTop}`);

                    // Update isAtBottom state
                    isAtBottom = true;
                    // Hide toggle button since we're at bottom with auto-scroll enabled
                    hideAutoScrollToggle();
                }
            } else {
                // Auto-scroll was disabled - restore previous scroll position
                if (typeof window.lastMessagesScrollPosition !== 'undefined') {
                    messagesList.scrollTop = window.lastMessagesScrollPosition;
                    // Update isAtBottom state based on restored position
                    isAtBottom = isAtBottomOfContainer(messagesList, 20);
                    // Show toggle button since auto-scroll is disabled
                    showAutoScrollToggle();
                } else {
                }
            }
        }, 50); // Reduced delay for more responsive feel
    }

    // Show/hide message filters based on active tab
    const messageFilters = document.getElementById('message-filters');
    if (tabName === 'memory') {
        messageFilters.style.display = 'none';

        // ALWAYS show auto-scroll toggle in memory view for better discoverability
        // This ensures users can always navigate back to messages and see any notifications
        showAutoScrollToggle();

        // Update UI to show return arrow and preserve glow effects
        updateAutoScrollToggleUI();
    } else {
        messageFilters.style.display = 'flex';

        // Update UI to show normal auto-scroll controls
        updateAutoScrollToggleUI();
    }
}

// View full value in modal
function viewFullValue(key) {
    if (window.sessionMemoryValues && window.sessionMemoryValues[key]) {
        let value = window.sessionMemoryValues[key];

        // Store current modal state
        currentModalKey = key;
        currentRawValue = value;

        // Try to parse JSON if it's a string
        let parsedValue = value;
        if (typeof value === 'string') {
            try {
                parsedValue = JSON.parse(value);
            } catch (e) {
                // If JSON parsing fails, treat as plain text
                parsedValue = value;
            }
        }
        currentParsedValue = parsedValue;

        // Set modal key
        document.getElementById('modal-key').textContent = key;

        // Reset view mode to highlighted
        currentViewMode = 'highlighted';
        document.getElementById('toggle-text').textContent = 'Raw';

        // Render content based on current view mode
        renderModalContent();

        document.getElementById('value-modal').style.display = 'block';
    } else {
        console.error('Session memory value not found for key:', key);
        document.getElementById('modal-key').textContent = key;
        document.getElementById('modal-value').textContent = 'Error: Value not found';
        document.getElementById('value-modal').style.display = 'block';
    }
}

// Render modal content based on current view mode
function renderModalContent() {
    const modalValueElement = document.getElementById('modal-value');

    if (currentViewMode === 'raw') {
        // Show raw JSON
        modalValueElement.innerHTML = `<pre><code>${escapeHtml(typeof currentRawValue === 'string' ? currentRawValue : JSON.stringify(currentRawValue, null, 2))}</code></pre>`;
    } else {
        // Show highlighted content
        if (shouldApplySyntaxHighlighting(currentParsedValue)) {
            const { code, language } = extractCodeFromValue(currentParsedValue);
            if (code && language) {
                modalValueElement.innerHTML = `<pre><code class="language-${language}">${escapeHtml(code)}</code></pre>`;
                // Apply syntax highlighting
                if (typeof Prism !== 'undefined') {
                    Prism.highlightElement(modalValueElement.querySelector('code'));
                }
            } else {
                // Fallback to JSON formatting with syntax highlighting
                modalValueElement.innerHTML = `<pre><code class="language-json">${escapeHtml(JSON.stringify(currentParsedValue, null, 2))}</code></pre>`;
                if (typeof Prism !== 'undefined') {
                    Prism.highlightElement(modalValueElement.querySelector('code'));
                }
            }
        } else {
            // Regular JSON display with syntax highlighting
            modalValueElement.innerHTML = `<pre><code class="language-json">${escapeHtml(JSON.stringify(currentParsedValue, null, 2))}</code></pre>`;
            if (typeof Prism !== 'undefined') {
                Prism.highlightElement(modalValueElement.querySelector('code'));
            }
        }
    }
}

// Toggle between highlighted and raw view
function toggleView() {
    if (currentViewMode === 'highlighted') {
        currentViewMode = 'raw';
        document.getElementById('toggle-text').textContent = 'Highlighted';
    } else {
        currentViewMode = 'highlighted';
        document.getElementById('toggle-text').textContent = 'Raw';
    }
    renderModalContent();
}

// Helper function to determine if value should have syntax highlighting
function shouldApplySyntaxHighlighting(value) {
    if (typeof value !== 'object' || value === null) return false;

    // Check for code-related fields
    return (
        value.hasOwnProperty('code') ||
        value.hasOwnProperty('language') ||
        value.hasOwnProperty('file_path') ||
        value.hasOwnProperty('function_name') ||
        (typeof value.content === 'string' && (
            value.content.includes('function ') ||
            value.content.includes('def ') ||
            value.content.includes('class ') ||
            value.content.includes('import ') ||
            value.content.includes('SELECT ') ||
            value.content.includes('#include') ||
            value.content.includes('<!DOCTYPE') ||
            value.content.includes('<script>') ||
            value.content.includes('```')
        ))
    );
}

// Helper function to extract code and language from value
function extractCodeFromValue(value) {
    if (!value || typeof value !== 'object') {
        return { code: null, language: null };
    }

    // Direct code field with language
    if (value.code && value.language) {
        return {
            code: value.code,
            language: mapLanguage(value.language)
        };
    }

    // Content field (common for markdown/documentation)
    if (value.content && typeof value.content === 'string') {
        // Detect language from content
        const detectedLanguage = detectLanguageFromContent(value.content);
        return {
            code: value.content,
            language: detectedLanguage
        };
    }

    // Code field without explicit language - try to detect
    if (value.code && typeof value.code === 'string') {
        const detectedLanguage = detectLanguageFromContent(value.code) ||
                                 detectLanguageFromPath(value.file_path);
        return {
            code: value.code,
            language: detectedLanguage || 'javascript'
        };
    }

    return { code: null, language: null };
}

// Map common language names to Prism.js language identifiers
function mapLanguage(lang) {
    const langMap = {
        'js': 'javascript',
        'ts': 'typescript',
        'py': 'python',
        'rb': 'ruby',
        'php': 'php',
        'java': 'java',
        'c': 'c',
        'cpp': 'cpp',
        'c++': 'cpp',
        'cs': 'csharp',
        'go': 'go',
        'rust': 'rust',
        'sql': 'sql',
        'html': 'html',
        'css': 'css',
        'scss': 'scss',
        'json': 'json',
        'xml': 'xml',
        'yaml': 'yaml',
        'yml': 'yaml',
        'markdown': 'markdown',
        'md': 'markdown',
        'bash': 'bash',
        'sh': 'bash',
        'shell': 'bash'
    };
    return langMap[lang.toLowerCase()] || lang.toLowerCase();
}

// Detect language from file path
function detectLanguageFromPath(filePath) {
    if (!filePath || typeof filePath !== 'string') return null;

    const extension = filePath.split('.').pop().toLowerCase();
    return mapLanguage(extension);
}

// Detect language from code content
function detectLanguageFromContent(content) {
    if (!content || typeof content !== 'string') return null;

    // Python patterns
    if (/def\s+\w+\s*\(|import\s+\w+|from\s+\w+\s+import|class\s+\w+.*:/i.test(content)) {
        return 'python';
    }

    // JavaScript patterns
    if (/function\s+\w+\s*\(|const\s+\w+\s*=|let\s+\w+\s*=|=>\s*{|console\.log/i.test(content)) {
        return 'javascript';
    }

    // SQL patterns
    if (/SELECT\s+.*FROM|INSERT\s+INTO|UPDATE\s+.*SET|DELETE\s+FROM|CREATE\s+TABLE/i.test(content)) {
        return 'sql';
    }

    // HTML patterns
    if (/<!DOCTYPE\s+html|<html|<head>|<body>|<div/i.test(content)) {
        return 'html';
    }

    // CSS patterns
    if (/\{[^}]*[a-z-]+\s*:\s*[^}]+\}|\.[a-z-]+\s*\{|#[a-z-]+\s*\{/i.test(content)) {
        return 'css';
    }

    // JSON patterns
    if (/^\s*[\{\[]/.test(content.trim()) && /[\}\]]\s*$/.test(content.trim())) {
        try {
            JSON.parse(content);
            return 'json';
        } catch (e) {
            // Not valid JSON
        }
    }

    // Bash/shell patterns
    if (/^#!\/bin\/(bash|sh)|echo\s+|ls\s+|cd\s+|mkdir\s+|rm\s+/i.test(content)) {
        return 'bash';
    }

    // Default to plain text for unknown content
    return null;
}

// Close modal
function closeModal() {
    document.getElementById('value-modal').style.display = 'none';
}

// Close modal when clicking outside
window.onclick = function(event) {
    const modal = document.getElementById('value-modal');
    if (event.target === modal) {
        closeModal();
    }
}

// Close modal when ESC key is pressed
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape' || event.keyCode === 27) {
        const modal = document.getElementById('value-modal');
        if (modal && modal.style.display === 'block') {
            closeModal();
        }
    }
});

// Copy to clipboard utility
function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        showNotification('Copied to clipboard!');
    }).catch(err => {
        console.error('Failed to copy: ', err);
        showNotification('Failed to copy', 'error');
    });
}

// Escape HTML for safety
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Simple notification system
function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;

    document.body.appendChild(notification);

    // Show notification
    setTimeout(() => {
        notification.classList.add('show');
    }, 100);

    // Hide and remove notification
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

// Update session header "Last Activity" timestamp in real-time
function updateSessionActivityTimestampFromMessage(messageData) {
    if (!messageData.timestamp) {
        return;
    }

    // Convert ISO timestamp to Unix seconds and Date object
    const messageTime = new Date(messageData.timestamp);
    const timestampSeconds = messageTime.getTime() / 1000;


    // Update the absolute timestamp display (Last Activity: 9/1/2025, 12:32:50 AM CST)
    // Find all timestamp-value elements and look for the one in the "Last Activity" meta-item
    const timestampElements = document.querySelectorAll('.meta-value.timestamp-value');

    for (let element of timestampElements) {
        const metaItem = element.closest('.meta-item');

        if (metaItem && metaItem.textContent.includes('Last Activity:')) {
            const formattedTime = messageTime.toLocaleString(undefined, {
                year: 'numeric',
                month: 'numeric',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            });

            // Clear the element and set the new timestamp
            element.innerHTML = '';
            element.textContent = formattedTime;
            break;
        }
    }

    // Update the relative timestamp display (just now, 5 minutes ago, etc.)
    const activityRelative = document.querySelector('.session-activity-relative');
    if (activityRelative) {
        // Update the data attribute with the message timestamp
        activityRelative.dataset.originalTimestamp = timestampSeconds.toString();

        // Calculate and display the new relative time
        const newRelativeTime = getRelativeTimestamp(timestampSeconds.toString());
        activityRelative.textContent = newRelativeTime;

    } else {
    }
}

// Update activity indicator timestamp when new message arrives
function updateActivityIndicatorForNewMessage() {
    const indicator = document.getElementById('activity-status-indicator');
    if (!indicator) return;

    // Set the current timestamp as the new activity time
    const currentTime = Date.now() / 1000; // Convert to seconds (Unix timestamp)
    indicator.dataset.activityTimestamp = currentTime.toString();

    // Immediately update the indicator appearance
    applyActivityStatusToIndicator();
}

// Apply activity status to the indicator
function applyActivityStatusToIndicator() {
    const indicator = document.getElementById('activity-status-indicator');
    if (!indicator) return;

    const activityTimestamp = indicator.dataset.activityTimestamp;
    const now = Date.now();

    if (activityTimestamp && /^\d+(\.\d+)?$/.test(activityTimestamp)) {
        const activityTime = parseFloat(activityTimestamp) * 1000; // Convert to milliseconds
        const timeDiff = now - activityTime;

        // Remove existing activity classes
        indicator.classList.remove('fresh', 'recent', 'stale', 'active', 'inactive');

        // Apply appropriate activity class based on time difference
        if (timeDiff <= 5 * 60 * 1000) { // < 5 minutes - fresh (green)
            indicator.classList.add('fresh');
            indicator.setAttribute('data-tooltip', 'Fresh: Active within 5 minutes');
        } else if (timeDiff <= 60 * 60 * 1000) { // < 1 hour - recent (yellow)
            indicator.classList.add('recent');
            indicator.setAttribute('data-tooltip', 'Recent: Active within 1 hour');
        } else { // > 1 hour - stale (gray)
            indicator.classList.add('stale');
            indicator.setAttribute('data-tooltip', 'Stale: No activity for over 1 hour');
        }
    } else {
        // No activity data, mark as stale
        indicator.classList.add('stale');
        indicator.setAttribute('data-tooltip', 'Stale: No activity for over 1 hour');
    }
}

// Prevent double tooltips by handling custom tooltip elements
function initializeCustomTooltips() {
    const elements = document.querySelectorAll('.session-header-controls [title], .status-badge[title]');
    elements.forEach(element => {
        const title = element.getAttribute('title');
        if (title) {
            // Store title in data attribute for CSS to use
            element.setAttribute('data-tooltip', title);
            // Remove title to prevent browser tooltip
            element.removeAttribute('title');
        }
    });
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    // Apply activity status to badge
    applyActivityStatusToIndicator();

    // Initialize custom tooltips
    initializeCustomTooltips();

    // Connect WebSocket
    connectWebSocket();

    // Initialize markdown rendering for existing messages
    initializeMarkdownRendering();

    // Initialize scroll detection for auto-scroll functionality
    initializeScrollDetection();

    // Scroll to most recent message
    scrollToLatestMessage();

    // Set up periodic activity status updates every 30 seconds
    setInterval(() => {
        applyActivityStatusToIndicator();
    }, 30000); // 30 seconds

    // Set up periodic timestamp refresh every 60 seconds
    setInterval(() => {
        refreshAllTimestamps();
    }, 60000); // 60 seconds
});

// Scroll to the most recent message
function scrollToLatestMessage() {
    const messagesList = document.getElementById('messages-list');
    const messages = messagesList.querySelectorAll('.message-item');

    if (messages.length > 0) {
        // Get the last message
        const lastMessage = messages[messages.length - 1];

        // Scroll to the bottom to show the complete message without sticky header issues
        lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }
}

// Initialize markdown rendering for message content
function initializeMarkdownRendering() {
    const messageElements = document.querySelectorAll('.message-text[data-markdown]');

    messageElements.forEach(element => {
        const markdownContent = element.getAttribute('data-markdown');
        if (markdownContent && typeof marked !== 'undefined' && typeof DOMPurify !== 'undefined') {
            try {
                // Configure marked.js for proper list rendering
                marked.setOptions({
                    gfm: true,
                    breaks: false,
                    pedantic: false,
                    sanitize: false
                });

                // Render markdown using marked.js (loaded from CDN in base.html)
                const rawHtmlContent = marked.parse(markdownContent);

                // Sanitize HTML to prevent XSS while preserving safe elements
                const sanitizedHtmlContent = DOMPurify.sanitize(rawHtmlContent, {
                    ALLOWED_TAGS: [
                        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                        'p', 'br', 'div', 'span',
                        'strong', 'b', 'em', 'i', 'u', 'code', 'pre',
                        'ul', 'ol', 'li',
                        'blockquote',
                        'a',
                        'table', 'thead', 'tbody', 'tr', 'th', 'td',
                        'input'
                    ],
                    ALLOWED_ATTR: [
                        'href', 'title', 'alt', 'class', 'id',
                        'type', 'checked', 'disabled', 'start'
                    ],
                    ALLOW_DATA_ATTR: false,
                    ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|#):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
                    FORBID_ATTR: ['onerror', 'onload', 'onclick', 'onmouseover', 'onfocus', 'onblur', 'onchange', 'onsubmit', 'src'],
                    FORBID_TAGS: ['script', 'object', 'embed', 'form', 'button', 'img'],
                    ADD_ATTR: ['target'],
                    // Only allow checkbox inputs from markdown
                    CUSTOM_ELEMENT_HANDLING: {
                        tagNameCheck: (tagName) => {
                            if (tagName === 'input') {
                                return /^input$/i.test(tagName);
                            }
                            return false;
                        },
                        attributeNameCheck: (attr) => /^(type|checked|disabled)$/i.test(attr),
                        allowCustomizedBuiltInElements: false
                    }
                });

                element.innerHTML = sanitizedHtmlContent;

                // Apply syntax highlighting if Prism is available
                if (typeof Prism !== 'undefined') {
                    const codeElements = element.querySelectorAll('code[class*="language-"]');
                    codeElements.forEach(code => {
                        Prism.highlightElement(code);
                    });
                }
            } catch (error) {
                console.error('Error rendering markdown:', error);
            }
        } else if (!markdownContent) {
            console.warn('No markdown content found in data-markdown attribute');
        } else if (typeof marked === 'undefined') {
            console.warn('Marked.js library not available');
        } else if (typeof DOMPurify === 'undefined') {
            console.warn('DOMPurify library not available - HTML sanitization disabled');
        }
    });
}

// Global variable to track markdown rendering state
let isMarkdownEnabled = true;

// Toggle between markdown rendering and raw text
function toggleMarkdownRendering() {
    isMarkdownEnabled = !isMarkdownEnabled;
    const toggleBtn = document.getElementById('markdown-toggle-btn');
    const messageElements = document.querySelectorAll('.message-text[data-markdown]');

    if (isMarkdownEnabled) {
        // Switch to markdown rendering
        toggleBtn.innerHTML = '<span class="btn-icon">üìù</span>';
        toggleBtn.setAttribute('data-tooltip', 'Toggle Markdown/Raw');
        toggleBtn.classList.remove('raw-mode');

        // Clean up raw text styling first
        messageElements.forEach(element => {
            element.classList.remove('raw-text');
            // Remove any pre elements that were added for raw display
            const preElements = element.querySelectorAll('pre');
            preElements.forEach(pre => pre.remove());
        });

        // Re-render all messages as markdown
        initializeMarkdownRendering();
    } else {
        // Switch to raw text display
        toggleBtn.innerHTML = '<span class="btn-icon">üìÑ</span>';
        toggleBtn.setAttribute('data-tooltip', 'Show Markdown');
        toggleBtn.classList.add('raw-mode');

        // Show raw markdown content with proper formatting
        messageElements.forEach(element => {
            const markdownContent = element.getAttribute('data-markdown');
            if (markdownContent) {
                // Decode HTML entities and preserve newlines
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = markdownContent;
                const decodedContent = tempDiv.textContent || tempDiv.innerText || markdownContent;

                // Create a pre element to preserve formatting
                element.innerHTML = '';
                const preElement = document.createElement('pre');
                preElement.textContent = decodedContent;
                preElement.style.whiteSpace = 'pre-wrap';
                preElement.style.margin = '0';
                preElement.style.fontFamily = 'inherit';
                element.appendChild(preElement);
                element.classList.add('raw-text');
            }
        });
    }
}

// Message visibility filtering
function filterMessages(visibility) {
    const messages = document.querySelectorAll('.message-item');
    const filterButtons = document.querySelectorAll('.filter-btn');

    // Update active button
    filterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.visibility === visibility);
    });

    // Filter messages
    messages.forEach(message => {
        const messageVisibility = message.dataset.visibility;
        if (visibility === 'all' || messageVisibility === visibility) {
            message.style.display = 'block';
        } else {
            message.style.display = 'none';
        }
    });

    // Update count in Messages tab
    const visibleCount = document.querySelectorAll('.message-item[style*="block"], .message-item:not([style*="none"])').length;
    const messagesTab = document.getElementById('messages-tab');
    if (messagesTab) {
        const originalText = messagesTab.textContent.replace(/Messages \(\d+\)/, `Messages (${visibleCount})`);
        messagesTab.textContent = originalText;
    }
}

// Session memory values for JavaScript access
window.sessionMemoryValues = {
    {% if session_memory %}
    {% for entry in session_memory %}
    "{{ entry.key|e }}": {{ entry.value|tojson }}{% if not loop.last %},{% endif %}
    {% endfor %}
    {% endif %}
};
</script>

<style>
/* Compact Layout - Reduce font sizes and spacing globally */

/* Session header compacting */
.session-title {
    font-size: 1.1rem !important;
    margin: 0 !important;
    line-height: 1.3 !important;
}

.session-meta {
    font-size: 0.75rem !important;
    gap: 1rem !important;
    margin: 0.5rem 0 !important;
}

.meta-label {
    font-size: 0.7rem !important;
    font-weight: 500 !important;
}

.meta-value {
    font-size: 0.75rem !important;
}

.session-header-controls {
    gap: 0.5rem !important;
}

.session-header-controls .btn {
    padding: 0.3rem 0.6rem !important;
    font-size: 0.8rem !important;
}

/* Tab navigation compacting */
.tab-button {
    padding: 0.6rem 1rem !important;
    font-size: 0.85rem !important;
    font-weight: 500 !important;
}

/* Message filters compacting */
.message-filters {
    padding: 0.5rem 0 !important;
    gap: 0.4rem !important;
}

.filter-label {
    font-size: 0.8rem !important;
    margin-right: 0.3rem !important;
}

.filter-btn {
    padding: 0.2rem 0.5rem !important;
    font-size: 0.75rem !important;
}

/* Message content compacting */
.message-header {
    margin-bottom: 0.5rem !important;
}

.message-sender {
    font-size: 0.8rem !important;
    font-weight: 600 !important;
}

.message-timestamp {
    font-size: 0.7rem !important;
}

.visibility-badge {
    font-size: 0.65rem !important;
    padding: 0.15rem 0.4rem !important;
}

.message-content {
    font-size: 0.85rem !important;
    line-height: 1.4 !important;
}

/* Sticky container compacting */
.sticky-nav-container {
    padding: 0.75rem !important;
}

.session-info {
    margin-bottom: 0.75rem !important;
}

.tab-container {
    margin-bottom: 0 !important;
}

/* General spacing reduction */
.session-content {
    padding-top: 0.5rem !important;
}

/* Activity indicator compacting */
.activity-indicator {
    width: 0.7rem !important;
    height: 0.7rem !important;
}

.activity-indicator .activity-dot {
    width: 0.7rem !important;
    height: 0.7rem !important;
    border-radius: 50% !important;
}

/* Copy button compacting */
.copy-btn {
    font-size: 0.7rem !important;
    padding: 0.1rem 0.3rem !important;
    margin-left: 0.3rem !important;
}

/* Timestamp relative text compacting */
.timestamp-relative {
    font-size: 0.65rem !important;
    opacity: 0.7 !important;
    margin-top: 0.1rem !important;
}

/* Message Filters */
.message-filters {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.filter-label {
    font-weight: 600;
    color: #6c757d;
    margin-right: 0.5rem;
}

.filter-btn {
    background: transparent;
    border: 1px solid #dee2e6;
    color: #6c757d;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9rem;
}

.filter-btn:hover {
    background: #0d6efd;
    color: white;
    border-color: #0d6efd;
}

.filter-btn.active {
    background: #198754;
    color: white;
    border-color: #198754;
}

/* Tab container styles */
.tab-container {
    overflow: hidden;
}

.tab-header {
    display: flex;
    background: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
}

.tab-button {
    flex: 1;
    padding: 1rem 1.5rem;
    border: none;
    background: transparent;
    color: #6c757d;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border-bottom: 3px solid transparent;
}

.tab-button:hover {
    background: #e9ecef;
    color: #495057;
}

.tab-button.active {
    background: white;
    color: #007bff;
    border-bottom-color: #007bff;
}

.tab-content {
    min-height: 400px;
}

.tab-pane {
    display: none;
    padding: 1.5rem;
}

.tab-pane.active {
    display: block;
}

/* Memory table styles */
.memory-table-container {
    overflow-x: auto;
    border-radius: 8px;
    border: 1px solid #dee2e6;
}

.memory-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
}

.memory-table th,
.memory-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid #dee2e6;
}

.memory-table th {
    background-color: #f8f9fa;
    font-weight: 600;
    color: #495057;
}

.memory-key code {
    background: #f1f3f4;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 0.85rem;
}

.agent-badge {
    background: #e3f2fd;
    color: #1976d2;
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: 500;
}

.value-preview {
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 0.85rem;
    color: #666;
}

.btn-sm {
    padding: 0.375rem 0.75rem;
    font-size: 0.875rem;
    border: 1px solid #ced4da;
    border-radius: 4px;
    background: #f8f9fa;
    color: #495057;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-sm:hover {
    background: #e9ecef;
    border-color: #adb5bd;
}

/* Empty state styles */
.empty-state {
    text-align: center;
    padding: 3rem 2rem;
    color: #6c757d;
}

.empty-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.7;
}

.empty-state h3 {
    margin-bottom: 0.5rem;
    color: #495057;
}

.empty-state p {
    margin: 0;
    opacity: 0.8;
}

/* Modal styles */
.modal {
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}

.modal-content {
    position: relative;
    background-color: white;
    margin: 5% auto;
    padding: 0;
    width: 80%;
    max-width: 800px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.modal-header {
    padding: 1.5rem;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

#view-toggle {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    color: #495057;
    padding: 0.25rem 0.75rem;
    font-size: 0.875rem;
    border-radius: 0.375rem;
}

#view-toggle:hover {
    background: #e9ecef;
    border-color: #adb5bd;
}

.modal-header h3 {
    margin: 0;
    color: #333;
}

.modal-close {
    font-size: 1.5rem;
    cursor: pointer;
    color: #999;
}

.modal-close:hover {
    color: #333;
}

.modal-body {
    padding: 1.5rem;
}

.modal-key,
.modal-value {
    margin-bottom: 1rem;
}

.modal-key code {
    background: #f1f3f4;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-family: 'Monaco', 'Menlo', monospace;
}

.modal-value pre {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid #e9ecef;
    white-space: pre-wrap;
    word-wrap: break-word;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 0.9rem;
    max-height: 400px;
    overflow-y: auto;
}

.modal-footer {
    padding: 1.5rem;
    border-top: 1px solid #eee;
    text-align: right;
}

.btn-secondary {
    padding: 0.5rem 1rem;
    border: 1px solid #ced4da;
    border-radius: 4px;
    background: #6c757d;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-secondary:hover {
    background: #5a6268;
    border-color: #545b62;
}

/* Auto-scroll toggle button styles */
.auto-scroll-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    min-width: 40px;
    height: 40px;
}

.auto-scroll-toggle.btn-primary {
    background: #28a745;
    border: 1px solid #28a745;
    color: white;
}

.auto-scroll-toggle.btn-primary:hover {
    background: #218838;
    border-color: #1e7e34;
    transform: translateY(-1px);
}

.auto-scroll-toggle.btn-secondary {
    background: #dc3545;
    border: 1px solid #dc3545;
    color: white;
}

.auto-scroll-toggle.btn-secondary:hover {
    background: #c82333;
    border-color: #bd2130;
    transform: translateY(-1px);
}

.auto-scroll-toggle .btn-icon {
    font-size: 1rem;
    line-height: 1;
}

.auto-scroll-toggle .toggle-text {
    font-size: 0.8rem;
    font-weight: 500;
}

.unread-badge {
    background: #dc3545;
    color: white;
    font-size: 0.65rem;
    font-weight: 600;
    padding: 0.15rem 0.4rem;
    border-radius: 8px;
    min-width: 1rem;
    text-align: center;
    line-height: 1;
}

/* Breathing notification effect for new messages */
.auto-scroll-toggle.new-messages-notification {
    animation: breathe-glow 2s ease-in-out infinite;
    position: relative;
    overflow: visible;
    z-index: 10;
    background: linear-gradient(45deg, #28a745, #20c997) !important;
    border-color: #28a745 !important;
    box-shadow: 0 0 15px rgba(40, 167, 69, 0.4);
}

.auto-scroll-toggle.new-messages-notification::before {
    content: '';
    position: absolute;
    top: -3px;
    left: -3px;
    right: -3px;
    bottom: -3px;
    border-radius: 9px;
    background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
    background-size: 400% 400%;
    animation: gradient-shift 3s ease infinite;
    z-index: -1;
    opacity: 0.7;
}

@keyframes breathe-glow {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 8px rgba(40, 167, 69, 0.5), 0 0 15px rgba(32, 201, 151, 0.3);
    }
    50% {
        transform: scale(1.08);
        box-shadow: 0 0 25px rgba(40, 167, 69, 0.8), 0 0 40px rgba(32, 201, 151, 0.6), 0 0 60px rgba(255, 193, 7, 0.4);
    }
}

@keyframes gradient-shift {
    0% {
        background-position: 0% 50%;
    }
    50% {
        background-position: 100% 50%;
    }
    100% {
        background-position: 0% 50%;
    }
}

/* Custom tooltip styles */
[data-tooltip] {
    position: relative;
    cursor: pointer;
}

[data-tooltip]:hover::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.85rem;
    font-weight: normal;
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
    opacity: 0;
    animation: tooltip-appear 0.2s ease-out forwards;
}

[data-tooltip]:hover::after {
    content: '';
    position: absolute;
    bottom: 115%;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid rgba(0, 0, 0, 0.9);
    z-index: 1000;
    pointer-events: none;
    opacity: 0;
    animation: tooltip-appear 0.2s ease-out forwards;
}

@keyframes tooltip-appear {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(4px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

/* Responsive design */
@media (max-width: 768px) {
    .tab-button {
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
    }

    .tab-pane {
        padding: 1rem;
    }

    .memory-table th,
    .memory-table td {
        padding: 0.5rem;
        font-size: 0.85rem;
    }
}
</style>
{% endblock %}
