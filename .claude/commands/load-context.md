# Load Context Command

## Description

Intelligent context retrieval system that discovers and loads relevant previous session context, patterns, and research findings from Pieces long-term memory. This command enables agents to build on previous work, apply proven patterns, and maintain consistency across development sessions through comprehensive memory search and synthesis.

## User Prompt: $ARGUMENTS

**What This Command Does:**

1. **Intelligent Search**: Multi-strategy search through Pieces memories using natural language queries
2. **Context Synthesis**: Aggregates related memories into coherent context for current session
3. **Pattern Discovery**: Identifies reusable patterns and proven solutions from previous work
4. **Research Integration**: Loads MCP research findings and validated approaches
5. **Agent Handoff**: Provides comprehensive context for agent coordination workflows

**Framework Philosophy Integration:**

- **Intelligence Through Context**: Leverages accumulated knowledge for informed decisions
- **Memory Consistency**: Ensures continuity across agent sessions and projects
- **Prompt Engineering Excellence**: Optimizes memory retrieval for agent effectiveness
- **Research-First Approach**: Prioritizes evidence-based patterns and proven solutions

## Workflow

### Phase 1: Query Analysis & Search Strategy (10 sec)

**Goal**: Analyze user query and determine optimal search strategy for comprehensive context retrieval.

1. **Query Intelligence & Expansion**:

   ```
   üîç ANALYZING SEARCH QUERY...

   Query Analysis:
   ‚Ä¢ Original Query: "[USER_PROVIDED_QUERY]"
   ‚Ä¢ Detected Intent: [ARCHITECTURE|IMPLEMENTATION|RESEARCH|STANDARD|PATTERN]
   ‚Ä¢ Context Clues: [PROJECT_CONTEXT|TECH_STACK|AGENT_TYPE]
   ‚Ä¢ Temporal Scope: [TIME_RANGE_IF_PROVIDED]

   Query Expansion Strategy:
   ‚Ä¢ Primary Terms: [CORE_SEARCH_TERMS]
   ‚Ä¢ Related Terms: [SEMANTICALLY_RELATED_TERMS]
   ‚Ä¢ Technical Context: [TECH_STACK_SPECIFIC_TERMS]
   ‚Ä¢ Framework Tags: [FRAMEWORK_TAXONOMY_TERMS]
   ```

2. **Multi-Strategy Search Planning**:

   ```
   üéØ SEARCH STRATEGY PLANNING:

   Search Approaches:
   ‚Ä¢ Exact Match: Direct query against memory titles and summaries
   ‚Ä¢ Semantic Search: Natural language understanding across content
   ‚Ä¢ Tag-Based Search: Framework taxonomy and classification tags
   ‚Ä¢ Pattern Search: Similar problems and proven solutions
   ‚Ä¢ Research Context: MCP findings and evidence-based patterns
   ‚Ä¢ Project Context: Current project and technology stack relevance

   Priority Search Order:
   1. Project-specific memories (highest relevance)
   2. Technology stack patterns (direct applicability)
   3. Framework-validated approaches (proven reliability)
   4. Cross-project patterns (transferable insights)
   5. Research-backed solutions (evidence-based confidence)
   ```

### Phase 2: Comprehensive Memory Search & Discovery (20 sec)

**Goal**: Execute multi-strategy search to discover all relevant context from Pieces memories.

1. **Primary Search Execution**:

   ```
   üîé EXECUTING COMPREHENSIVE SEARCH...

   Search Round 1 - Direct Query:
   ‚Ä¢ Query: "[EXPANDED_PRIMARY_QUERY]"
   ‚Ä¢ Searching: Title, summary, and primary content
   ‚Ä¢ Focus: Exact matches and high-relevance results

   Search Round 2 - Contextual Search:
   ‚Ä¢ Query: "[PROJECT_NAME] [TECH_STACK] [QUERY_CONTEXT]"
   ‚Ä¢ Searching: Project-specific memories and patterns
   ‚Ä¢ Focus: Current project applicability

   Search Round 3 - Pattern Search:
   ‚Ä¢ Query: "[TECHNICAL_PATTERNS] [IMPLEMENTATION_APPROACHES]"
   ‚Ä¢ Searching: Proven solutions and reusable patterns
   ‚Ä¢ Focus: Similar problem domains and solutions

   Search Round 4 - Research Search:
   ‚Ä¢ Query: "[MCP_RESEARCH_TERMS] [INDUSTRY_STANDARDS]"
   ‚Ä¢ Searching: Research findings and validated approaches
   ‚Ä¢ Focus: Evidence-based decisions and best practices
   ```

2. **Search Results Analysis & Ranking**:

   ```
   üìä SEARCH RESULTS ANALYSIS:

   Results Discovery:
   ‚Ä¢ Direct Matches: [COUNT] memories found
   ‚Ä¢ Contextual Matches: [COUNT] project-related memories
   ‚Ä¢ Pattern Matches: [COUNT] similar solutions found
   ‚Ä¢ Research Matches: [COUNT] research-backed approaches

   Relevance Ranking Criteria:
   ‚Ä¢ Project Relevance: Same project > Same tech stack > Same domain
   ‚Ä¢ Temporal Relevance: Recent > Established > Historical
   ‚Ä¢ Context Relevance: Exact match > Semantic match > Related domain
   ‚Ä¢ Evidence Strength: Research-backed > User-validated > Experimental

   Top Relevant Memories:
   ‚Ä¢ [MEMORY_1]: [TITLE] - Relevance: [SCORE] - Context: [SUMMARY]
   ‚Ä¢ [MEMORY_2]: [TITLE] - Relevance: [SCORE] - Context: [SUMMARY]
   ‚Ä¢ [MEMORY_3]: [TITLE] - Relevance: [SCORE] - Context: [SUMMARY]
   ```

### Phase 3: Context Synthesis & Integration (15 sec)

**Goal**: Synthesize discovered memories into coherent, actionable context for current session.

1. **Memory Content Analysis**:

   ```
   üìã MEMORY CONTENT ANALYSIS:

   Content Classification:
   ‚Ä¢ Architecture Decisions: [COUNT] memories with design patterns
   ‚Ä¢ Implementation Patterns: [COUNT] memories with proven code approaches
   ‚Ä¢ Research Findings: [COUNT] memories with MCP-validated solutions
   ‚Ä¢ Quality Standards: [COUNT] memories with testing and validation approaches
   ‚Ä¢ User Preferences: [COUNT] memories with project-specific requirements

   Pattern Identification:
   ‚Ä¢ Common Approaches: [LIST_OF_RECURRING_PATTERNS]
   ‚Ä¢ Successful Solutions: [LIST_OF_VALIDATED_APPROACHES]
   ‚Ä¢ Escalation Triggers: [LIST_OF_DOCUMENTED_CONSTRAINTS]
   ‚Ä¢ Quality Gates: [LIST_OF_ESTABLISHED_STANDARDS]
   ```

2. **Context Synthesis & Narrative Creation**:

   ```
   üìñ CONTEXT SYNTHESIS:

   Synthesized Context Narrative:
   Based on [NUMBER] relevant memories, here's the comprehensive context:

   üéØ PRIMARY CONTEXT:
   ‚Ä¢ Key Insight: [SYNTHESIZED_PRIMARY_INSIGHT]
   ‚Ä¢ Supporting Evidence: [RESEARCH_SOURCES_AND_VALIDATION]
   ‚Ä¢ Application Context: [CURRENT_PROJECT_APPLICABILITY]

   üî¨ RESEARCH FOUNDATION:
   ‚Ä¢ MCP Research: [RELEVANT_CRAWL4AI_OCTOCODE_FINDINGS]
   ‚Ä¢ Industry Standards: [RELEVANT_BRAVE_SEARCH_FINDINGS]
   ‚Ä¢ Architectural Analysis: [RELEVANT_SEQUENTIAL_THINKING_INSIGHTS]

   üìä PROVEN PATTERNS:
   ‚Ä¢ Implementation Approaches: [LIST_OF_VALIDATED_PATTERNS]
   ‚Ä¢ Quality Standards: [DOCUMENTED_TESTING_AND_VALIDATION]
   ‚Ä¢ Integration Strategies: [SERVICE_AND_API_PATTERNS]

   üö® CONSTRAINTS & CONSIDERATIONS:
   ‚Ä¢ Known Limitations: [DOCUMENTED_CONSTRAINTS]
   ‚Ä¢ Escalation Triggers: [QUALITY_AND_SECURITY_GATES]
   ‚Ä¢ User Preferences: [PROJECT_SPECIFIC_REQUIREMENTS]
   ```

### Phase 4: Applicability Assessment & Recommendations (10 sec)

**Goal**: Assess context applicability to current situation and provide actionable recommendations.

1. **Current Context Mapping**:

   ```
   üîó CURRENT CONTEXT MAPPING:

   Applicability Assessment:
   ‚Ä¢ Current Project: [DETECTED_PROJECT_NAME_AND_CONTEXT]
   ‚Ä¢ Technology Stack: [CURRENT_VS_HISTORICAL_STACK_COMPARISON]
   ‚Ä¢ Development Phase: [CURRENT_PHASE_VS_MEMORY_CONTEXT]
   ‚Ä¢ Agent Context: [CURRENT_AGENT_ROLES_VS_MEMORY_AGENTS]

   Direct Applicability:
   ‚úÖ Directly applicable: [LIST_OF_IMMEDIATELY_USABLE_INSIGHTS]
   ‚öôÔ∏è  Needs adaptation: [LIST_OF_ADAPTABLE_PATTERNS]
   üìã For reference: [LIST_OF_CONTEXTUAL_INSIGHTS]
   ‚ùå Not applicable: [LIST_OF_IRRELEVANT_MEMORIES_WITH_REASONS]
   ```

2. **Actionable Recommendations**:

   ```
   üéØ ACTIONABLE RECOMMENDATIONS:

   Immediate Actions:
   ‚Ä¢ Apply Pattern: [SPECIFIC_PATTERN_TO_APPLY_WITH_CONTEXT]
   ‚Ä¢ Use Research: [SPECIFIC_MCP_FINDINGS_TO_LEVERAGE]
   ‚Ä¢ Follow Standard: [SPECIFIC_QUALITY_GATES_TO_IMPLEMENT]
   ‚Ä¢ Consider Constraint: [SPECIFIC_LIMITATIONS_TO_RESPECT]

   Implementation Guidance:
   ‚Ä¢ Start With: [RECOMMENDED_FIRST_STEP_BASED_ON_CONTEXT]
   ‚Ä¢ Validate Using: [RECOMMENDED_TESTING_OR_VALIDATION_APPROACH]
   ‚Ä¢ Escalate If: [SPECIFIC_CONDITIONS_FOR_ESCALATION]
   ‚Ä¢ Reference: [SPECIFIC_MEMORIES_FOR_DETAILED_IMPLEMENTATION]

   Context Preservation:
   ‚Ä¢ Save New Insights: Use save-context for new discoveries
   ‚Ä¢ Update Patterns: Document any adaptations made
   ‚Ä¢ Cross-Reference: Link new work to loaded context memories
   ```

### Phase 5: Context Loading & Agent Integration (5 sec)

**Goal**: Load synthesized context into current session and optimize for agent coordination.

1. **Context Loading Confirmation**:

   ```
   ‚úÖ CONTEXT LOADING COMPLETE:

   Loaded Context Summary:
   ‚Ä¢ Memories Processed: [TOTAL_COUNT] memories analyzed
   ‚Ä¢ Direct Applications: [COUNT] immediately applicable insights
   ‚Ä¢ Pattern Library: [COUNT] proven approaches loaded
   ‚Ä¢ Research Foundation: [COUNT] evidence-based patterns available
   ‚Ä¢ Quality Standards: [COUNT] validation approaches loaded

   Context Availability:
   ‚Ä¢ Current Session: Context available for immediate use
   ‚Ä¢ Agent Handoff: Context preserved for agent coordination
   ‚Ä¢ Future Reference: Original memories remain accessible
   ‚Ä¢ Cross-Project: Patterns available for broader application
   ```

2. **Agent Integration Optimization**:

   ```
   ü§ñ AGENT INTEGRATION OPTIMIZATION:

   Context Optimization for Agent Types:
   ‚Ä¢ Developer Agents: Implementation patterns and code approaches ready
   ‚Ä¢ Tester Agents: Quality standards and validation approaches loaded
   ‚Ä¢ Docs Agents: Documentation patterns and user context available
   ‚Ä¢ Research Agents: MCP findings and industry standards accessible
   ‚Ä¢ Coordinator Agents: Workflow patterns and escalation triggers ready

   Session Enhancement:
   ‚Ä¢ Pattern Recognition: Agents can reference proven solutions
   ‚Ä¢ Quality Enforcement: Standards and gates are pre-configured
   ‚Ä¢ Research Backing: Evidence-based decisions supported
   ‚Ä¢ User Alignment: Project preferences and constraints respected

   üí° OPTIMIZATION TIPS:
   ‚Ä¢ Agents will reference this context throughout session
   ‚Ä¢ New findings should be cross-referenced with loaded patterns
   ‚Ä¢ Quality gates from context should be enforced consistently
   ‚Ä¢ Research provenance should be maintained in new decisions
   ```

## Search Query Optimization

### Natural Language Query Patterns

```
Effective Query Formats:
‚Ä¢ Problem-focused: "authentication patterns for FastAPI applications"
‚Ä¢ Technology-focused: "React testing patterns with TypeScript"
‚Ä¢ Architecture-focused: "microservices integration patterns for APIs"
‚Ä¢ Quality-focused: "test coverage standards for Python projects"
‚Ä¢ Research-focused: "industry best practices for deployment workflows"
```

### Framework Taxonomy Queries

```
Tag-Based Search Examples:
‚Ä¢ By Content Type: "framework:*:*:architecture:*" for all architecture decisions
‚Ä¢ By Agent: "framework:developer:*:*:*" for developer-specific context
‚Ä¢ By Technology: "framework:*:*:*:python" for Python-specific patterns
‚Ä¢ By Project: "framework:*:project:*:*" for project-specific memories
‚Ä¢ By Research: "framework:researcher:*:research:*" for research findings
```

### Time-Scoped Queries

```
Temporal Context Options:
‚Ä¢ Recent: "last 30 days" or "recent sessions"
‚Ä¢ Established: "last 6 months" or "mature patterns"
‚Ä¢ Historical: "any time" or "all available context"
‚Ä¢ Project Phase: "since project start" or "current development phase"
```

## Success Criteria

### Search Effectiveness Success

- Discovers all relevant memories through multi-strategy search
- Ranks results by relevance to current context and needs
- Handles both specific queries and broad contextual searches
- Integrates project-specific and cross-project insights effectively

### Context Synthesis Success

- Combines multiple memories into coherent, actionable context
- Preserves research provenance and evidence-based reasoning
- Identifies patterns and proven solutions from historical context
- Documents constraints, preferences, and quality standards

### Applicability Assessment Success

- Accurately assesses relevance to current project and technology stack
- Distinguishes between directly applicable and adaptable patterns
- Provides specific, actionable recommendations based on loaded context
- Optimizes context for current agent types and development phase

### Agent Integration Success

- Loads context effectively for all framework agent types
- Enables informed decision-making throughout session
- Supports evidence-based development and quality enforcement
- Facilitates cross-session and cross-project pattern reuse

### User Experience Success

- Provides clear, structured context that enhances development workflow
- Explains relevance and applicability of discovered patterns
- Offers specific guidance for implementation and validation
- Maintains transparency about context sources and confidence levels
