# PRP-1.0.3: Dynamic Usage Guidance Tool

**Status**: Planning
**Created**: 2025-01-14
**Type**: Feature Implementation

## Problem Statement

Agents in multi-agent workflows need contextual, JWT access-level appropriate guidance on:
- What operations they can perform at their current access level
- How to coordinate multi-agent workflows securely
- What security boundaries exist and operational patterns
- How to properly distribute and manage JWT tokens

Currently, users must manually determine their capabilities and operational patterns, leading to potential security boundary violations and suboptimal usage patterns.

## Minimal Solution

**Core Implementation**: Single MCP tool `get_usage_guidance` that analyzes the caller's JWT authentication context and returns tailored operational guidance.

**Key Features**:
- JWT-based access level detection (ADMIN, AGENT, READ_ONLY)
- Four guidance types: operations, coordination, security, troubleshooting
- Leverages existing authentication infrastructure
- Full agent orchestration support

## Existing Tools We Can Reuse

Our current infrastructure provides excellent foundation:

1. **JWT Authentication System** (`auth.py:63-217`):
   - `JWTAuthenticationManager` with role-based permissions
   - `AgentIdentity` with permission checking
   - Existing permission levels: read, write, admin, debug

2. **Tool Registry System** (`tools.py:64-108`):
   - `TOOL_REGISTRY` with metadata for all available tools
   - Tool categorization and discovery functions
   - Permission requirements per tool

3. **Error Handling** (`utils/llm_errors.py`):
   - Consistent error response patterns
   - LLM-friendly error messages with suggestions

## Implementation Approach

### 1. Tool Definition
Add `get_usage_guidance` to the FastMCP server following existing patterns:

```python
@app.tool()
async def get_usage_guidance(
    ctx: Context,
    auth_token: Optional[str] = None,
    guidance_type: str = "operations"
) -> dict[str, Any]
```

### 2. Core Logic Flow
1. **Extract Agent Context**: Use existing `extract_agent_context(ctx, auth_token)`
2. **Determine Access Level**: Map JWT permissions to ADMIN/AGENT/READ_ONLY
3. **Generate Guidance**: Create response based on access level and guidance_type
4. **Return Structured Response**: Following existing error handling patterns

### 3. Access Level Mapping
```python
def determine_access_level(permissions: list[str]) -> str:
    if "admin" in permissions:
        return "ADMIN"
    elif "write" in permissions:
        return "AGENT"
    else:
        return "READ_ONLY"
```

### 4. Guidance Generation
Each guidance type returns:
- **operations**: Available tools + usage patterns
- **coordination**: Multi-agent workflow instructions
- **security**: Permission boundaries and best practices
- **troubleshooting**: Common issues and solutions

## Quality Considerations

**Security**:
- Server-side JWT validation using existing authentication infrastructure
- No token leakage in responses
- Audit logging for guidance requests

**Performance**:
- Leverage existing tool registry for fast lookups
- Simple permission mapping without complex logic
- Response caching can be added later if needed

**Maintainability**:
- Single tool addition to existing FastMCP server
- Uses established patterns from `auth.py` and `tools.py`
- Follows existing error handling conventions

## Implementation Steps

1. **Add Tool Definition** to FastMCP server (1 hour)
2. **Implement Core Logic** using existing auth patterns (2 hours)
3. **Create Response Generators** for each guidance type (3 hours)
4. **Add to Tool Registry** with proper metadata (30 minutes)
5. **Write Unit Tests** following existing test patterns (2 hours)
6. **Integration Testing** with JWT scenarios (1 hour)

**Total Estimate**: 1 day implementation

## YAGNI Notes

**What we're NOT building initially**:
- Performance optimization/caching (add if needed)
- Complex permission hierarchies (current 4 levels sufficient)
- Persistent guidance customization (static responses work fine)
- Detailed analytics/metrics (basic audit logging sufficient)

**What we can add later**:
- Response caching for frequently requested guidance
- Customizable guidance templates
- Enhanced role-based guidance patterns
- Performance metrics and monitoring

## Testing Strategy

**Unit Tests**:
- JWT validation with various token types and access levels
- Response format validation for all guidance types
- Permission boundary enforcement

**Integration Tests**:
- Multi-agent coordination scenarios using guidance
- Token expiry and refresh workflows
- Security boundary validation

**Behavioral Tests**:
- End-to-end agent workflows using guidance
- Cross-agent handoff patterns
- Error recovery scenarios

## Success Metrics

- **Functionality**: All guidance types work for all access levels
- **Security**: No privilege escalation or token leakage incidents
- **Usability**: Agents can determine their capabilities autonomously
- **Maintainability**: Uses existing patterns, easy to extend

## Dependencies

**Required**:
- Existing JWT authentication system (`auth.py`)
- FastMCP server framework (`server.py`)
- Tool registry system (`tools.py`)
- Error handling utilities (`utils/llm_errors.py`)

**Optional**:
- Database connection for audit logging (already available)

## Risk Assessment

**Low Risk**:
- Builds entirely on existing, proven infrastructure
- Single tool addition with minimal surface area
- No database schema changes required
- Uses established authentication patterns

**Mitigation**:
- Comprehensive testing with existing auth scenarios
- Follow security patterns from `security-authentication.md`
- Use existing error handling for consistent responses
